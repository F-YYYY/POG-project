import pandas as pd
import math
from typing import Dict, Optional, List, Tuple, Any


class RemoveSKU:
    """
    RemoveSKU ç±»
    ------------------
    å…¨å±€åˆ é™¤ SKUï¼ˆä¸å†é™å®š module_id + layer_idï¼‰ï¼Œ
    å¦‚æœå•†å“åœ¨æ‰˜ç›˜(tray)ä¸Šï¼Œåˆ™é˜»æ­¢åˆ é™¤å¹¶è¿”å›è¯¥ SKU æ‰€åœ¨çš„æ‰€æœ‰æ‰˜ç›˜ï¼ˆæ”¯æŒå¤šå¯¹å¤šæ˜ å°„ï¼‰ã€‚
    è¿”å› (new_pog, status_dict) å½¢å¼ï¼ˆä¸åŸæµç¨‹å…¼å®¹ï¼‰ã€‚
    """

    def __init__(self):
        self.dataframes: Dict[str, pd.DataFrame] = {}
        self.affected_layers_by_removal: List[Tuple[int, int]] = []
        print("âœ… RemoveSKU åˆå§‹åŒ–å®Œæˆã€‚")

    def remove_sku_items(self, var_dict: Dict[str, Any]):
        pog_data: pd.DataFrame = var_dict['bases_data']['pog_data']
        tray_item_data: Optional[pd.DataFrame] = var_dict['bases_data'].get('tray_item', None)
        params = var_dict['func'].get('del_item_func', {})

        delete_skus = params.get('del_item_list', [])

        print(f"\n--- å¼€å§‹æ‰§è¡Œ 'remove_sku_items' å…¨å±€åˆ é™¤SKU: {delete_skus} ---")

        if pog_data is None or pog_data.empty:
            return pog_data, {'status': 'fail', 'msg': 'POGæ•°æ®ä¸ºç©º'}

        pog_data = pog_data.copy()
        pog_data['item_code'] = pog_data['item_code'].astype(str)

        # ==== tray-item å¯¹åº”å…³ç³» ====
        # å»ºç«‹ item_code -> [tray_id, ...] æ˜ å°„ (item_to_trays)
        # ä»¥åŠ tray_id -> [item_code, ...] åå‘æ˜ å°„ (tray_to_items)
        item_to_trays: Dict[str, List[str]] = {}
        tray_to_items: Dict[str, List[str]] = {}
        if tray_item_data is not None and not tray_item_data.empty:
            try:
                pair = tray_item_data.iloc[:, [0, 1]].copy()
                pair.columns = ['tray_id', 'item_code']
                pair['tray_id'] = pair['tray_id'].astype(str)
                pair['item_code'] = pair['item_code'].astype(str)
                for _, r in pair.iterrows():
                    tid = r['tray_id']
                    it = r['item_code']
                    item_to_trays.setdefault(it, []).append(tid)
                    tray_to_items.setdefault(tid, []).append(it)
                print(f"ğŸ“¦ è½½å…¥ tray_item æ˜ å°„ï¼Œå…± {len(pair)} æ¡è®°å½•ï¼Œitem->tray æ˜ å°„é¡¹æ•° {len(item_to_trays)}ã€‚")
            except Exception as e:
                print(f"âš ï¸ å¤„ç† tray_item æ–‡ä»¶å‡ºé”™ï¼š{e}")
                item_to_trays = {}
                tray_to_items = {}
        else:
            print("â„¹ï¸ æœªæä¾› tray_item æ•°æ®æˆ–æ–‡ä»¶ä¸ºç©ºï¼Œè·³è¿‡ tray-item æ˜ å°„æ£€æŸ¥ã€‚")

        # ==== å…¨å±€æœç´¢è¦åˆ é™¤çš„å•†å“ ====
        found_rows = pog_data[pog_data['item_code'].isin([str(x) for x in delete_skus])]
        if found_rows.empty:
            return pog_data, {
                'status': 'fail',
                'msg': f'æœªæ‰¾åˆ°å•†å“ {delete_skus}'
            }

        # ==== è‹¥ä»»ä½•è¦åˆ  SKU åœ¨ tray ä¸Šï¼Œé˜»æ­¢åˆ é™¤å¹¶è¿”å›è¯¥ SKU çš„æ‰€æœ‰ tray åˆ—è¡¨ï¼ˆitem->traysï¼‰ï¼Œä»¥åŠ tray->items åˆ—è¡¨ ====
        sku_on_trays = {}
        for sku in delete_skus:
            sku_str = str(sku)
            if sku_str in item_to_trays:
                sku_on_trays[sku_str] = item_to_trays[sku_str]

        if sku_on_trays:
            # æ„å»ºå‹å¥½ msgï¼ˆåˆ—å‡ºæ¯ä¸ª SKU çš„ tray åˆ—è¡¨ï¼‰
            parts = []
            for sku, trays in sku_on_trays.items():
                parts.append(f"SKU {sku} ä½äºæ‰˜ç›˜: {', '.join(trays)}")
            msg = "åˆ é™¤å¤±è´¥ï¼šå­˜åœ¨å•†å“ä½äºæ‰˜ç›˜ä¸Šï¼Œè¯¦æƒ…å¦‚ä¸‹ï¼š " + "ï¼›".join(parts) + "ã€‚è¯·å…ˆå¤„ç†æ‰˜ç›˜åé‡è¯•ã€‚"
            status = {
                'status': 'fail',
                'msg': msg,
                'item_trays': sku_on_trays,   # item -> [tray_id]
                'tray_items': tray_to_items   # tray_id -> [item_code, ...]
            }
            return pog_data, status

        # ==== ç¦æ­¢åˆ é™¤æ‰˜ç›˜è‡ªèº«ï¼ˆè‹¥ pog_data ä¸­æœ‰ item_type å­—æ®µï¼‰ ====
        if 'item_type' in pog_data.columns:
            tray_self = pog_data.loc[pog_data['item_type'] == 'tray', 'item_code'].astype(str).tolist()
            for code in delete_skus:
                if str(code) in tray_self:
                    return pog_data, {
                        'status': 'fail',
                        'msg': f'åˆ é™¤å¤±è´¥ï¼šSKU {code} æ˜¯æ‰˜ç›˜(tray)å•†å“ï¼Œç¦æ­¢åˆ é™¤ã€‚'
                    }

        # ==== è®°å½•å—å½±å“å±‚ï¼ˆå…¨å±€åˆ é™¤ï¼Œå› æ­¤å¤šä¸ªå±‚éƒ½å¯èƒ½å—å½±å“ï¼‰ ====
        affected_layers = found_rows[['module_id', 'layer_id']].drop_duplicates()
        self.affected_layers_by_removal = [tuple(x) for x in affected_layers.to_numpy()]

        # ==== æ‰§è¡Œåˆ é™¤ ====
        new_pog = pog_data.drop(found_rows.index).reset_index(drop=True)
        removed_num = len(found_rows)
        print(f"ğŸ—‘ï¸ å·²åˆ é™¤ {removed_num} æ¡SKUè®°å½•ï¼ˆå…¨å±€ï¼‰ã€‚")

        status_dict = {
            'status': 'success',
            'msg': f'æˆåŠŸåˆ é™¤ {removed_num} ä¸ªSKU'
        }
        return new_pog, status_dict


class FillLayerSKU(RemoveSKU):
    """
    FillLayerSKU ç±»
    ------------------
    åˆ é™¤SKUåï¼š
    1. è®¡ç®—å—å½±å“å±‚å‰©ä½™ç©ºé—´ï¼ˆåŸºäº baselineï¼‰
    2. åœ¨æ¯ä¸ªå—å½±å“å±‚ä½¿ç”¨ 0-1 åŠ¨æ€è§„åˆ’ï¼ˆKnapsackï¼‰é€‰æ‹©é¢å¤– +1 facing çš„ SKU é›†åˆä»¥æœ€å¤§åŒ– revenue
      ï¼ˆæ¯ä¸ª SKU æœ€å¤š +1ï¼‰
    3. è‹¥æ— æ³•å¢åŠ ä»»ä½• facingï¼Œåˆ™ä»…ç­‰è·é‡æ’ï¼ˆå«ä¸¤ç«¯ç©ºéš™ï¼‰
    4. çº¦æŸï¼šæ¯å±‚æœ€ç»ˆå±•ç¤ºå•å…ƒæ•° <= 18ï¼ˆè¶…è¿‡æ—¶æŒ‰ revenue ä¼˜å…ˆä¿ç•™ï¼‰
    5. spacing ä¸ position å‘ä¸‹å–æ•´ä¸ºæ•´æ•°
    6. è¾“å‡ºæ—¶ä¼šè°ƒæ•´ facing åˆ—ï¼Œåæ˜ æœ€ç»ˆæ¯ä¸ª base item çš„ facing æ•°é‡
    """

    def __init__(self):
        super().__init__()
        self.affected_layer_space: Optional[pd.DataFrame] = None
        self.sorted_items_by_position: Dict[Tuple[int, int], pd.DataFrame] = {}
        self.sales_df: Optional[pd.DataFrame] = None

        self.max_items_per_layer = 18
        print("âœ… FillLayerSKU åˆå§‹åŒ–å®Œæˆã€‚")

    def analyze_layer_space(self, pog_data: pd.DataFrame) -> pd.DataFrame:
        """
        è‡ªåŠ¨ä» pog_data ä¸­è¯»å– module_widthï¼ˆæ¯å±‚çœŸå®å®½åº¦ï¼‰
        ä¸å†ä½¿ç”¨å›ºå®šçš„ dp_capacity_baseline=995
        """
        if pog_data.empty:
            return pd.DataFrame(columns=['module_id', 'layer_id', 'item_count', 'used_width', 'remaining_width'])

        # â‘  æ¯å±‚çœŸå®å®½åº¦ = pog_data ä¸­è¯¥å±‚æ‰€æœ‰è¡Œçš„ module_width çš„æœ€å¤§å€¼
        #   ï¼ˆå› ä¸ºåŒä¸€å±‚å¤šè¡Œé‡å¤ï¼Œç›´æ¥ max æˆ– unique éƒ½å¯ï¼‰
        layer_width = pog_data.groupby(['module_id', 'layer_id'])['module_width'].max().reset_index()
        layer_width.rename(columns={'module_width': 'total_width'}, inplace=True)

        # â‘¡ è®¡ç®—æ¯å±‚ç‰©å“å®½åº¦å’Œæ•°é‡
        layer_summary = pog_data.groupby(['module_id', 'layer_id']).agg(
            used_width=('item_width', 'sum'),
            item_count=('item_code', 'count')
        ).reset_index()

        # â‘¢ åˆå¹¶
        layer_summary = layer_summary.merge(layer_width, on=['module_id', 'layer_id'], how='left')

        # â‘£ è®¡ç®—å‰©ä½™å®½åº¦
        layer_summary['remaining_width'] = (layer_summary['total_width'] - layer_summary['used_width']).astype(int)

        return layer_summary

    def calculate_space_for_affected_layers(self, pog_data: pd.DataFrame, total_layer_width: int = None):
        """
        è®¡ç®—è¢«åˆ é™¤å•†å“åå—å½±å“å±‚çš„å‰©ä½™ç©ºé—´ã€‚
        ä¸å†ä½¿ç”¨å›ºå®šå®½åº¦ï¼Œè€Œæ˜¯ä» pog_data ä¸­è¯»å–æ¯å±‚ module_widthã€‚
        """
        print("\n--- è®¡ç®—å—å½±å“å±‚å‰©ä½™ç©ºé—´ï¼ˆè‡ªåŠ¨è¯»å– module_widthï¼‰ ---")

        if not self.affected_layers_by_removal:
            print("â„¹ï¸ æ— å—å½±å“å±‚ã€‚")
            return

        # â˜… analyze_layer_space ä¸å†éœ€è¦ total_layer_width
        all_layers = self.analyze_layer_space(pog_data)

        # ç­›é€‰è¢«å½±å“å±‚
        affected = all_layers.set_index(['module_id', 'layer_id']) \
            .reindex(self.affected_layers_by_removal)

        self.affected_layer_space = affected.reset_index()
        print("âœ… å—å½±å“å±‚ç©ºé—´è®¡ç®—å®Œæˆï¼ˆå·²åŸºäº module_widthï¼‰ã€‚")

    def sort_items_by_position(self, pog_data: pd.DataFrame):
        print("\n--- æ’åºå—å½±å“å±‚å†…å•†å“ ---")
        self.sorted_items_by_position.clear()
        for mod_id, lay_id in self.affected_layers_by_removal:
            df = pog_data[(pog_data['module_id'] == mod_id) & (pog_data['layer_id'] == lay_id)].copy()
            if df.empty:
                continue
            if 'position' in df.columns:
                sorted_df = df.sort_values(by='position')
            else:
                sorted_df = df
            self.sorted_items_by_position[(mod_id, lay_id)] = sorted_df.reset_index(drop=True)
        print("âœ… æ’åºå®Œæˆã€‚")

    @staticmethod
    def _knapsack_01(weights: List[int], values: List[float], capacity: int) -> set:
        n = len(weights)
        if n == 0 or capacity <= 0:
            return set()
        dp = [0.0] * (capacity + 1)
        choose = [[False] * (capacity + 1) for _ in range(n)]
        for i in range(n):
            wt = weights[i]
            val = values[i]
            if wt <= 0:
                continue
            for w in range(capacity, wt - 1, -1):
                if dp[w - wt] + val > dp[w]:
                    dp[w] = dp[w - wt] + val
                    choose[i][w] = True
        chosen = set()
        w = capacity
        for i in range(n - 1, -1, -1):
            if w >= 0 and choose[i][w]:
                chosen.add(i)
                w -= weights[i]
        return chosen

    def _enforce_max_items(self, df_layer_items: pd.DataFrame) -> pd.DataFrame:
        if len(df_layer_items) <= self.max_items_per_layer:
            return df_layer_items
        df = df_layer_items.copy().reset_index(drop=False)
        if 'revenue' not in df.columns:
            df['revenue'] = 0.0
        df_sorted = df.sort_values(by=['revenue', 'index'], ascending=[False, True])
        df_keep = df_sorted.head(self.max_items_per_layer).sort_values(by='index')
        df_keep = df_keep.drop(columns=['index']).reset_index(drop=True)
        return df_keep

    def fill_and_reposition_layers(self, pog_data: pd.DataFrame, total_layer_width: int = None):
        """
        å¡«å……ä¸é‡æ–°å®šä½ï¼ˆåŸºäºæ¯å±‚çœŸå® module_widthï¼‰ã€‚
        å·²åšé²æ£’æ€§æ”¹è¿›ï¼šæ¨¡å—/å±‚ id æ¯”è¾ƒæ—¶æŒ‰å­—ç¬¦ä¸²ï¼Œç¼ºå¤±å®½åº¦å›é€€åˆ° baselineï¼Œ
        spacing/position å‘ä¸‹å–æ•´ï¼ˆintï¼‰ã€‚
        """
        # å¦‚æœå¤–éƒ¨è¿˜ä¼ äº† total_layer_width å‚æ•°ä¼šè¢«å¿½ç•¥ â€”â€” æˆ‘ä»¬ä¼˜å…ˆä½¿ç”¨æ¯å±‚çš„ module_width
        print("\n--- å¼€å§‹æ‰§è¡Œ DP-based å¡«å……ä¸é‡æ–°å®šä½ï¼ˆåŸºäºçœŸå® module_widthï¼‰ ---")
        updated_layers = []

        # è·å–æ¯å±‚ç©ºé—´è¡¨ï¼ˆåŒ…å« total_width, remaining_widthï¼‰
        layer_space = self.analyze_layer_space(pog_data)

        for layer_key, layer_df in self.sorted_items_by_position.items():
            mod_id, lay_id = layer_key
            print(f"\nå¤„ç†å±‚ï¼šmodule {mod_id} - layer {lay_id}")

            # ä»¥å­—ç¬¦ä¸²æ–¹å¼åŒ¹é…ï¼Œé¿å… int/str ç±»å‹å·®å¼‚å¯¼è‡´æ— æ³•æ‰¾åˆ°è¡Œ
            row = layer_space[
                (layer_space['module_id'].astype(str) == str(mod_id)) &
                (layer_space['layer_id'].astype(str) == str(lay_id))
                ]

            if row.empty:
                print(f"âš ï¸ æ‰¾ä¸åˆ°å±‚ {mod_id}-{lay_id} çš„ module_width/å‰©ä½™å®½åº¦ä¿¡æ¯ï¼Œè·³è¿‡è¯¥å±‚ã€‚")
                continue

            # è¯»å– total_width ä¸ remaining_widthï¼Œå¿…è¦æ—¶å›é€€åˆ° baseline
            # ç¡®ä¿ numeric å¹¶è½¬æ¢ä¸º int
            try:
                total_layer_width_val = row['total_width'].iloc[0]
                total_layer_width = int(total_layer_width_val) if pd.notna(total_layer_width_val) else None
            except Exception:
                total_layer_width = None

            try:
                remaining_width_val = row['remaining_width'].iloc[0]
                remaining_width = int(remaining_width_val) if pd.notna(remaining_width_val) else None
            except Exception:
                remaining_width = None

            # å›é€€ç­–ç•¥
            baseline = getattr(self, 'dp_capacity_baseline', 995)
            if total_layer_width is None:
                total_layer_width = int(baseline)
                print(f"âš ï¸ total_width ç¼ºå¤±ï¼Œå›é€€åˆ° baseline = {total_layer_width} mm")
            if remaining_width is None:
                # è‹¥å‰©ä½™å®½åº¦ç¼ºå¤±ï¼Œç”¨ total - used_width è®¡ç®—ï¼ˆè‹¥èƒ½ï¼‰ï¼Œå¦åˆ™è®¾ä¸º 0
                used_w = row.get('used_width', None)
                if used_w is not None and len(used_w) > 0 and pd.notna(used_w.iloc[0]):
                    try:
                        remaining_width = int(max(0, int(total_layer_width) - int(used_w.iloc[0])))
                    except Exception:
                        remaining_width = 0
                else:
                    remaining_width = 0
                print(f"âš ï¸ remaining_width ç¼ºå¤±ï¼Œå›é€€ä¸º {remaining_width} mm")

            print(f"è¯¥å±‚å®é™…å®½åº¦ module_width = {total_layer_width} mmï¼Œå‰©ä½™å®½åº¦ = {remaining_width} mm")

            # candidatesï¼šæ’é™¤ tray
            candidates_df = layer_df.copy()
            if 'item_type' in candidates_df.columns:
                candidates_df = candidates_df[candidates_df['item_type'] != 'tray'].copy()

            # å¦‚æœæ²¡æœ‰å€™é€‰é¡¹ï¼Œç›´æ¥ç­‰è·é‡æ’æ•´å±‚ï¼ˆspacing å‘ä¸‹å–æ•´ï¼‰
            if candidates_df.empty:
                new_items = [r.to_dict() for _, r in layer_df.iterrows()]
                total_width_calc = sum(int(i.get('item_width', 0)) for i in new_items)
                num = len(new_items)
                spacing = math.floor((total_layer_width - total_width_calc) / (num + 1)) if num > 0 else 0
                pos = spacing
                for item in new_items:
                    item['position'] = int(pos)
                    pos += int(item.get('item_width', 0)) + spacing
                updated_layers.append(pd.DataFrame(new_items))
                continue

            # è®¡ç®— revenue å¹¶å‡†å¤‡ weights/values
            cand = candidates_df.copy()
            cand['item_code'] = cand['item_code'].astype(str)
            if self.sales_df is not None:
                cand = cand.merge(self.sales_df[['item_code', 'revenue']], on='item_code', how='left')
                cand['revenue'] = cand['revenue'].fillna(0.0)
            else:
                cand['revenue'] = 0.0

            weights = cand['item_width'].astype(int).tolist()
            values = cand['revenue'].astype(float).tolist()

            feasible_idx = [i for i, w in enumerate(weights) if w <= remaining_width and w > 0]
            if not feasible_idx:
                # ç­‰è·é‡æ’ï¼ˆæ— æ³•æ–°å¢ facingï¼‰
                new_items = [r.to_dict() for _, r in layer_df.iterrows()]
                total_width_calc = sum(int(i.get('item_width', 0)) for i in new_items)
                num = len(new_items)
                spacing = math.floor((total_layer_width - total_width_calc) / (num + 1)) if num > 0 else 0
                pos = spacing
                for item in new_items:
                    item['position'] = int(pos)
                    pos += int(item.get('item_width', 0)) + spacing
                updated_layers.append(pd.DataFrame(new_items))
                continue

            cand_weights = [weights[i] for i in feasible_idx]
            cand_values = [values[i] for i in feasible_idx]

            chosen_local = self._knapsack_01(cand_weights, cand_values, remaining_width)
            chosen_global_idx = [feasible_idx[i] for i in chosen_local]

            picked_codes = {str(cand.iloc[idx]['item_code']) for idx in chosen_global_idx}

            if picked_codes:
                total_gain = sum(float(cand.iloc[idx]['revenue']) for idx in chosen_global_idx)
                print(f"DP é€‰æ‹©çš„ SKU é›†åˆ: {picked_codes}ï¼Œé¢„è®¡é¢å¤– revenue: {total_gain:.3f}")
            else:
                print("DP æœªé€‰æ‹©ä»»ä½•é¢å¤– facingï¼ˆæˆ–æ”¶ç›Šä¸º0ï¼‰ï¼Œå°†ç­‰è·é‡æ’ã€‚")

            # ç”Ÿæˆæ–°å±‚è¡Œï¼ˆå¸¦ double æ ‡è®°çš„ item_codeï¼‰
            new_items = []
            for _, row_item in layer_df.iterrows():
                base_item = row_item.to_dict()
                code = str(base_item['item_code'])
                base_item['item_width'] = int(base_item.get('item_width', 0))
                revenue_val = 0.0
                if self.sales_df is not None:
                    r = self.sales_df.loc[self.sales_df['item_code'] == code]
                    if not r.empty:
                        revenue_val = float(r['revenue'].iloc[0])
                base_item['revenue'] = revenue_val

                if code in picked_codes:
                    i1 = base_item.copy();
                    i2 = base_item.copy()
                    i1['item_code'] = f"{code}(1)";
                    i2['item_code'] = f"{code}(2)"
                    new_items.extend([i1, i2])
                else:
                    new_items.append(base_item)

            df_new = pd.DataFrame(new_items)
            df_new = self._enforce_max_items(df_new)

            # ç­‰è·é‡æ’ï¼ˆä½¿ç”¨çœŸå® total_layer_widthï¼‰ï¼Œspacing/position å‘ä¸‹å–æ•´ä¸º int
            total_width_calc = int(df_new['item_width'].astype(int).sum()) if not df_new.empty else 0
            num_items = len(df_new)
            spacing = math.floor((total_layer_width - total_width_calc) / (num_items + 1)) if num_items > 0 else 0
            pos = spacing
            positions = []
            for idx in range(num_items):
                positions.append(int(pos))
                pos += int(df_new.iloc[idx]['item_width']) + spacing
            df_new = df_new.reset_index(drop=True)
            df_new['position'] = positions

            updated_layers.append(df_new)

        # åˆå¹¶å¹¶è®¡ç®— facing
        if not updated_layers:
            return pog_data, {'status': 'success', 'msg': 'æ— å¯æ›´æ–°å±‚'}

        new_layers = pd.concat(updated_layers, ignore_index=True)
        unaffected = pog_data.set_index(['module_id', 'layer_id']).drop(
            index=pd.MultiIndex.from_tuples(self.affected_layers_by_removal, names=['module_id', 'layer_id']),
            errors='ignore'
        ).reset_index()

        new_pog = pd.concat([unaffected, new_layers], ignore_index=True)

        def base_code(ic: str) -> str:
            if isinstance(ic, str) and '(' in ic and ic.endswith(')'):
                return ic.split('(')[0]
            return ic

        new_pog = new_pog.reset_index(drop=True)
        new_pog['base_item_code'] = new_pog['item_code'].astype(str).apply(base_code)
        facing_counts = new_pog['base_item_code'].value_counts().to_dict()
        new_pog['facing'] = new_pog['base_item_code'].map(lambda x: int(facing_counts.get(x, 0)))
        new_pog.drop(columns=['base_item_code'], inplace=True)

        print("âœ… DP-based å¡«å……ä¸é‡æ–°å®šä½å®Œæˆï¼ˆåŸºäº module_widthï¼‰ã€‚")
        return new_pog, {'status': 'success', 'msg': 'å¡«å……ä¸é‡æ–°å®šä½æˆåŠŸ'}

    def run_delete_fill_pipeline(self, var_dict: Dict[str, Any]) -> Tuple[pd.DataFrame, Dict[str, Any]]:
        pog_data = var_dict['bases_data']['pog_data']
        pog_data = pog_data.copy()
        pog_data['item_code'] = pog_data['item_code'].astype(str)
        var_dict['bases_data']['pog_data'] = pog_data

        sales_df = var_dict['bases_data'].get('sales_item_sum', None)
        if sales_df is not None and not sales_df.empty:
            sales_df = sales_df.copy()
            if 'item_code' in sales_df.columns and 'sales' in sales_df.columns and 'qty' in sales_df.columns:
                sales_df['item_code'] = sales_df['item_code'].astype(str)
                sales_df['revenue'] = sales_df['sales'].astype(float) * sales_df['qty'].astype(float)
                self.sales_df = sales_df[['item_code', 'revenue']].copy()
                print("âœ… å·²è½½å…¥ sales_item_sumï¼Œå¹¶è®¡ç®— revenue = sales * qtyã€‚")
            else:
                print("âš ï¸ sales_item_sum æ–‡ä»¶ç¼ºå°‘å¿…è¦åˆ— (item_code, sales, qty)ã€‚å°†é»˜è®¤ revenue=0ã€‚")
                self.sales_df = None
        else:
            print("â„¹ï¸ æœªæä¾› sales_item_sumï¼Œdouble é€‰æ‹©é»˜è®¤ revenue=0ã€‚")
            self.sales_df = None

        new_pog, status = self.remove_sku_items(var_dict)
        if status.get('status') == 'fail':
            return new_pog, status

        self.calculate_space_for_affected_layers(new_pog)
        self.sort_items_by_position(new_pog)

        final_pog, status2 = self.fill_and_reposition_layers(new_pog)
        return final_pog, status2


# ===========================
# ç¤ºä¾‹è°ƒç”¨ï¼ˆè¯·æŒ‰ä½ æœ¬åœ°è·¯å¾„ä¿®æ”¹ï¼‰
# ===========================
if __name__ == "__main__":
    pog_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_result.csv"
    tray_item_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_test_haircare_tray_item.csv"
    sales_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\sales_item_sum.csv"

    var_dict = {
        'bases_data': {
            'pog_data': pd.read_csv(pog_file),
            'tray_item': pd.read_csv(tray_item_file),
            'sales_item_sum': pd.read_csv(sales_file)
        },
        'func': {
            'del_item_func': {
                'del_item_list': ['101412643','101412641']
            }
        }
    }

    filler = FillLayerSKU()
    new_pog, status = filler.run_delete_fill_pipeline(var_dict)

    print(status)
    if status['status'] == 'success':
        output_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_result_final_output.csv"
        new_pog.to_csv(output_file, index=False, encoding='utf-8-sig')
        print(f"âœ… æœ€ç»ˆç»“æœå·²å¯¼å‡ºè‡³: {output_file}")
    else:
        # è‹¥æ˜¯å› ä¸º SKU åœ¨ tray ä¸Šè¢«é˜»æ­¢åˆ é™¤ï¼Œstatus ä¼šåŒ…å« 'item_trays' å’Œ 'tray_items'
        if status.get('item_trays') or status.get('tray_items'):
            print("âš ï¸ éƒ¨åˆ†æˆ–å…¨éƒ¨ SKU ä½äºæ‰˜ç›˜ä¸Šï¼Œå·²é˜»æ­¢åˆ é™¤ã€‚è¯¦è§ status['item_trays'] ä¸ status['tray_items']")
            print(status.get('msg'))
        else:
            print("âŒ æ“ä½œå¤±è´¥ï¼š", status.get('msg', 'æœªçŸ¥é”™è¯¯'))
