import pandas as pd
import math
from typing import Dict, Optional, List, Tuple


class RemoveSKU:
    """
    RemoveSKU ç±»
    ------------------
    å…¨å±€åˆ é™¤ SKUï¼ˆä¸å†é™å®š module_id + layer_idï¼‰ï¼Œ
    å¦‚æœå•†å“åœ¨æ‰˜ç›˜(tray)ä¸Šï¼Œåˆ™è¾“å‡ºè¯¥æ‰˜ç›˜ä¸Šçš„æ‰€æœ‰å•†å“ä¿¡æ¯ã€‚
    è¿”å› (new_pog, status_dict) å½¢å¼ï¼ˆä¸åŸæµç¨‹å…¼å®¹ï¼‰ã€‚
    """

    def __init__(self):
        self.dataframes: Dict[str, pd.DataFrame] = {}
        self.affected_layers_by_removal: List[Tuple[int, int]] = []
        print("âœ… RemoveSKU åˆå§‹åŒ–å®Œæˆã€‚")

    def remove_sku_items(self, var_dict: Dict):
        pog_data = var_dict['bases_data']['pog_data']
        tray_item_data = var_dict['bases_data'].get('tray_item', None)
        params = var_dict['func'].get('del_item_func', {})

        delete_skus = params.get('del_item_list', [])

        print(f"\n--- å¼€å§‹æ‰§è¡Œ 'remove_sku_items' å…¨å±€åˆ é™¤SKU: {delete_skus} ---")

        if pog_data is None or pog_data.empty:
            return pog_data, {'status': 'fail', 'msg': 'POGæ•°æ®ä¸ºç©º'}

        pog_data['item_code'] = pog_data['item_code'].astype(str)

        # ==== tray-item å¯¹åº”å…³ç³» ====
        tray_items = []
        tray_links = {}  # item_code -> tray_id
        tray_to_items = {}  # tray_id -> list of item_codes (åå‘æ˜ å°„)
        if tray_item_data is not None and not tray_item_data.empty:
            try:
                tray_pair_df = tray_item_data.iloc[:, [0, 1]].copy()
                tray_pair_df.columns = ['tray_id', 'item_code']
                tray_pair_df['tray_id'] = tray_pair_df['tray_id'].astype(str)
                tray_pair_df['item_code'] = tray_pair_df['item_code'].astype(str)
                tray_items = tray_pair_df['item_code'].tolist()
                tray_links = dict(zip(tray_pair_df['item_code'], tray_pair_df['tray_id']))

                # æ„å»ºåå‘æ˜ å°„ï¼štray_id -> [item_code1, item_code2, ...]
                for _, row in tray_pair_df.iterrows():
                    tray_id = row['tray_id']
                    item_code = row['item_code']
                    if tray_id not in tray_to_items:
                        tray_to_items[tray_id] = []
                    tray_to_items[tray_id].append(item_code)

                print(f"ğŸ“¦ æ‰˜ç›˜å•†å“è¯†åˆ«æˆåŠŸï¼šå…± {len(tray_items)} ä¸ª tray-item å…³è”ã€‚")
            except Exception as e:
                print(f"âš ï¸ è¯»å– tray_item æ–‡ä»¶å‡ºé”™: {e}")

        # ==== å…¨å±€æœç´¢è¦åˆ é™¤çš„å•†å“ ====
        found_rows = pog_data[pog_data['item_code'].isin(delete_skus)]
        if found_rows.empty:
            return pog_data, {
                'status': 'fail',
                'msg': f'æœªæ‰¾åˆ°å•†å“ {delete_skus}'
            }

        # ==== æ£€æŸ¥æ˜¯å¦æœ‰å•†å“åœ¨æ‰˜ç›˜ä¸Šï¼Œå¦‚æœæœ‰åˆ™æ”¶é›†è¯¥æ‰˜ç›˜ä¸Šçš„æ‰€æœ‰å•†å“ä¿¡æ¯ ====
        tray_items_info = {}  # {tray_id: [item_code1, item_code2, ...]}
        for code in delete_skus:
            code_str = str(code)
            if code_str in tray_items:
                tray_id = tray_links.get(code_str)
                if tray_id and tray_id in tray_to_items:
                    # æ‰¾åˆ°è¯¥æ‰˜ç›˜ä¸Šçš„æ‰€æœ‰å•†å“
                    items_on_tray = tray_to_items[tray_id]
                    tray_items_info[tray_id] = items_on_tray
                    print(f"ğŸ“¦ å•†å“ {code_str} ä½äºæ‰˜ç›˜ {tray_id} ä¸Šï¼Œè¯¥æ‰˜ç›˜åŒ…å«å•†å“: {items_on_tray}")

        # ==== ç¦æ­¢åˆ é™¤æ‰˜ç›˜è‡ªèº« ====
        if 'item_type' in pog_data.columns:
            tray_self = pog_data.loc[pog_data['item_type'] == 'tray', 'item_code'].astype(str).tolist()
            for code in delete_skus:
                if str(code) in tray_self:
                    return pog_data, {
                        'status': 'fail',
                        'msg': f'åˆ é™¤å¤±è´¥ï¼šSKU {code} æ˜¯æ‰˜ç›˜(tray)å•†å“ï¼Œç¦æ­¢åˆ é™¤ã€‚'
                    }

        # ==== è®°å½•å—å½±å“å±‚ ====
        affected_layers = found_rows[['module_id', 'layer_id']].drop_duplicates()
        self.affected_layers_by_removal = [tuple(x) for x in affected_layers.to_numpy()]

        # ==== æ‰§è¡Œåˆ é™¤ ====
        new_pog = pog_data.drop(found_rows.index)
        removed_num = len(found_rows)
        print(f"ğŸ—‘ï¸ å·²åˆ é™¤ {removed_num} æ¡SKUè®°å½•ã€‚")

        # ==== æ„å»ºè¿”å›ä¿¡æ¯ ====
        status_dict = {
            'status': 'success',
            'msg': f'æˆåŠŸåˆ é™¤ {removed_num} ä¸ªSKU'
        }

        # å¦‚æœæœ‰å•†å“åœ¨æ‰˜ç›˜ä¸Šï¼Œå°†æ‰˜ç›˜å•†å“ä¿¡æ¯æ·»åŠ åˆ°è¿”å›ç»“æœä¸­
        if tray_items_info:
            status_dict['tray_items'] = tray_items_info
            status_dict['msg'] += f'ï¼Œå‘ç° {len(tray_items_info)} ä¸ªæ‰˜ç›˜åŒ…å«è¢«åˆ é™¤å•†å“'

        return new_pog, status_dict


class FillLayerSKU(RemoveSKU):
    """
    FillLayerSKU ç±»
    ------------------
    åˆ é™¤SKUåï¼š
    1. è®¡ç®—å‰©ä½™ç©ºé—´
    2. ä½¿ç”¨ 0-1 åŠ¨æ€è§„åˆ’ï¼ˆKnapsackï¼‰åœ¨å‰©ä½™å®½åº¦ä¸‹é€‰ä¸€ç»„ SKU çš„é¢å¤– facingï¼ˆæ¯ä¸ª SKU æœ€å¤š +1ï¼‰ä»¥æœ€å¤§åŒ– revenue
    3. è‹¥æ— æ³•å¢åŠ ä»»ä½• facingï¼Œåˆ™ä»…ç­‰è·é‡æ’ï¼ˆå«ä¸¤ç«¯ç©ºéš™ï¼‰
    """

    def __init__(self):
        super().__init__()
        self.affected_layer_space: Optional[pd.DataFrame] = None
        self.sorted_items_by_position: Dict[Tuple[int, int], pd.DataFrame] = {}
        self.sales_df: Optional[pd.DataFrame] = None
        # èƒŒåŒ…åŸºå‡†å®½åº¦ â€” æŒ‰ä½ ä¹‹å‰çº¦å®šç”¨ 995mm ä½œä¸ºä¸Šé™åŸºå‡†ï¼ˆå¯ä¿®æ”¹ï¼‰
        self.dp_capacity_baseline = 995
        print("âœ… FillLayerSKU åˆå§‹åŒ–å®Œæˆã€‚")

    def analyze_layer_space(self, pog_data: pd.DataFrame, total_layer_width: int = None) -> pd.DataFrame:
        # å¦‚æœæœªä¼  total_layer_widthï¼Œåˆ™ä½¿ç”¨ baselineï¼ˆä»¥ä¾¿ä¿æŒä¸€è‡´ï¼‰
        if total_layer_width is None:
            total_layer_width = self.dp_capacity_baseline
        if pog_data.empty:
            return pd.DataFrame(columns=['module_id', 'layer_id', 'item_count', 'used_width', 'remaining_width'])
        layer_summary = pog_data.groupby(['module_id', 'layer_id']).agg(
            used_width=('item_width', 'sum'),
            item_count=('item_code', 'count')
        ).reset_index()
        layer_summary['total_width'] = total_layer_width
        layer_summary['remaining_width'] = layer_summary['total_width'] - layer_summary['used_width']
        return layer_summary

    def calculate_space_for_affected_layers(self, pog_data: pd.DataFrame, total_layer_width: int = None):
        print("\n--- è®¡ç®—å—å½±å“å±‚å‰©ä½™ç©ºé—´ ---")
        if total_layer_width is None:
            total_layer_width = self.dp_capacity_baseline
        if not self.affected_layers_by_removal:
            print("â„¹ï¸ æ— å—å½±å“å±‚ã€‚")
            return
        all_layers = self.analyze_layer_space(pog_data, total_layer_width)
        affected = all_layers.set_index(['module_id', 'layer_id']).reindex(self.affected_layers_by_removal)
        self.affected_layer_space = affected.reset_index()
        print("âœ… å—å½±å“å±‚ç©ºé—´è®¡ç®—å®Œæˆã€‚")

    def sort_items_by_position(self, pog_data: pd.DataFrame):
        print("\n--- æ’åºå—å½±å“å±‚å†…å•†å“ ---")
        self.sorted_items_by_position.clear()
        for mod_id, lay_id in self.affected_layers_by_removal:
            df = pog_data[(pog_data['module_id'] == mod_id) & (pog_data['layer_id'] == lay_id)].copy()
            if df.empty:
                continue
            sorted_df = df.sort_values(by='position')
            self.sorted_items_by_position[(mod_id, lay_id)] = sorted_df
        print("âœ… æ’åºå®Œæˆã€‚")

    @staticmethod
    def _knapsack_01(weights: List[int], values: List[float], capacity: int):
        """
        0-1 knapsack dynamic programming (returns indices selected)
        weights: list of positive ints
        values: list of floats (values)
        capacity: int capacity
        è¿”å›: set(selected indices)
        """
        n = len(weights)
        if n == 0 or capacity <= 0:
            return set()

        # dp[w] = max value achievable with capacity w
        dp = [0.0] * (capacity + 1)
        # keep choice info: for reconstruction, keep a 2D predecessor or use item-based backtracking table
        # ä¸ºèŠ‚çœå†…å­˜ï¼Œç”¨äºŒç»´è¡¨è®°å½•æ˜¯å¦é€‰æ‹© item i at capacity w
        choose = [[False] * (capacity + 1) for _ in range(n)]

        for i in range(n):
            wt = weights[i]
            val = values[i]
            # traverse capacity descending for 0-1 knapsack
            for w in range(capacity, wt - 1, -1):
                if dp[w - wt] + val > dp[w]:
                    dp[w] = dp[w - wt] + val
                    choose[i][w] = True

        # reconstruct chosen indices
        w = capacity
        chosen = set()
        for i in range(n - 1, -1, -1):
            if w >= 0 and choose[i][w]:
                chosen.add(i)
                w -= weights[i]

        return chosen

    def fill_and_reposition_layers(self, pog_data: pd.DataFrame, total_layer_width: int = None):
        """
        ä½¿ç”¨ 0-1 DP é€‰å‡ºè¦å¢åŠ çš„ facingï¼ˆæ¯ä¸ª SKU æœ€å¤š +1ï¼‰ã€‚
        é‡æ’æ—¶é‡‡ç”¨â€œä¸¤ç«¯ç•™ç©ºâ€çš„ç­‰è·åˆ†å¸ƒï¼ˆä¸åŸé€»è¾‘ä¿æŒä¸€è‡´ï¼‰ã€‚
        """
        if total_layer_width is None:
            total_layer_width = self.dp_capacity_baseline

        print("\n--- å¼€å§‹æ‰§è¡Œ DP-based å¡«å……ä¸é‡æ–°å®šä½ï¼ˆ0-1 Knapsackï¼‰ ---")
        updated_layers = []

        for layer_key, layer_df in self.sorted_items_by_position.items():
            mod_id, lay_id = layer_key
            print(f"\nå¤„ç†å±‚ï¼šmodule {mod_id} - layer {lay_id}")

            # è·å–è¯¥å±‚å‰©ä½™å®½åº¦ï¼ˆåŸºäº analyze_layer_space çš„ baselineï¼‰
            layer_space = self.analyze_layer_space(pog_data, total_layer_width)
            remain_series = layer_space[
                (layer_space['module_id'] == mod_id) &
                (layer_space['layer_id'] == lay_id)
                ]['remaining_width']
            if remain_series.empty:
                print(f"âš ï¸ æ— æ³•è¯»å–å±‚ {mod_id}-{lay_id} çš„å‰©ä½™å®½åº¦ï¼Œè·³è¿‡ã€‚")
                continue
            remaining_width = int(max(0, int(remain_series.iloc[0])))  # è½¬ä¸ºæ•´æ•°æ¯«ç±³
            print(f"å‰©ä½™å®½åº¦ï¼ˆcapacityï¼‰: {remaining_width} mm")

            # ä»…è€ƒè™‘é tray items ä½œä¸º candidateï¼ˆä¸”å¿…é¡»åœ¨è¯¥å±‚å­˜åœ¨ï¼‰
            candidates_df = layer_df.copy()
            if 'item_type' in candidates_df.columns:
                candidates_df = candidates_df[candidates_df['item_type'] != 'tray'].copy()
            if candidates_df.empty:
                print("æ— å€™é€‰å•†å“ï¼ˆétrayï¼‰ï¼Œè·³è¿‡è¯¥å±‚ã€‚")
                # ä»éœ€é‡æ’ä»¥ä¿è¯é—´è·ä¸€è‡´ -> ä½†è‹¥æ— å˜åŒ–å¯ç›´æ¥è·³è¿‡
                continue

            # è®¡ç®— revenue = sales * qtyï¼ˆsales_df å·²åœ¨ run_delete_fill_pipeline é‡Œé¢„å¤„ç†ï¼‰
            # å°† revenue åˆå¹¶è¿›å€™é€‰
            cand = candidates_df.copy()
            if self.sales_df is not None:
                # sales_df å·²åŒ…å« item_code (str) ä¸ revenue å­—æ®µ
                cand = cand.merge(self.sales_df[['item_code', 'revenue']], on='item_code', how='left')
                cand['revenue'] = cand['revenue'].fillna(0.0)
            else:
                cand['revenue'] = 0.0

            # weights / values for DP
            weights: List[int] = cand['item_width'].astype(int).tolist()
            values: List[float] = cand['revenue'].astype(float).tolist()

            # filter out items whose width > remaining_width (they can't be added)
            feasible_idx = [i for i, w in enumerate(weights) if w <= remaining_width and w > 0]
            if not feasible_idx:
                print("æ²¡æœ‰å®½åº¦å¯æ”¾ä¸‹çš„å€™é€‰å•†å“ï¼Œæ‰§è¡Œç­‰è·é‡æ’ã€‚")
                # æŒ‰ç…§åŸé€»è¾‘åšç­‰è·é‡æ’ï¼ˆæ— æ–°å¢ facingï¼‰
                new_items = []
                for _, row in layer_df.iterrows():
                    new_items.append(row.to_dict())
                total_width = sum(i['item_width'] for i in new_items)
                spacing = math.floor((total_layer_width - total_width) / (len(new_items) + 1)) if len(
                    new_items) > 0 else 0
                pos = spacing
                for item in new_items:
                    item['position'] = pos
                    pos += item['item_width'] + spacing
                updated_layers.append(pd.DataFrame(new_items))
                continue

            # prepare arrays limited to candidates
            cand_weights = [weights[i] for i in feasible_idx]
            cand_values = [values[i] for i in feasible_idx]

            # run knapsack (capacity = remaining_width)
            chosen_indices_local = self._knapsack_01(cand_weights, cand_values, remaining_width)

            # map back to original candidate indices
            chosen_global_idx = [feasible_idx[i] for i in chosen_indices_local]

            picked_codes = set()
            for idx in chosen_global_idx:
                picked_codes.add(str(cand.iloc[idx]['item_code']))

            if picked_codes:
                total_gain = sum(float(cand.iloc[idx]['revenue']) for idx in chosen_global_idx)
                print(f"DP é€‰æ‹©çš„ SKU é›†åˆ: {picked_codes}ï¼Œé¢„è®¡é¢å¤– revenue: {total_gain:.3f}")
            else:
                print("DP æœªé€‰æ‹©ä»»ä½•é¢å¤– facingï¼ˆæˆ–æ”¶ç›Šä¸º0ï¼‰ï¼Œè¿›è¡Œç­‰è·é‡æ’ã€‚")

            # æ„å»ºæ–°å±‚æ•°æ®ï¼ˆåŸä»¶ + å¤åˆ¶å“ï¼‰
            new_items = []
            # we iterate original layer_df order (sorted by position)
            for _, row in layer_df.iterrows():
                base_item = row.to_dict()
                code = str(base_item['item_code'])
                # å¦‚æœè¢«é€‰ä¸­doubleï¼Œå°±ç”Ÿæˆä¸¤ä¸ªå¹¶åŠ æ ‡å·
                if code in picked_codes:
                    item1 = base_item.copy()
                    item2 = base_item.copy()
                    item1['item_code'] = f"{code}(1)"
                    item2['item_code'] = f"{code}(2)"
                    new_items.extend([item1, item2])
                else:
                    new_items.append(base_item)

            # è®¡ç®—ç­‰è·ä½ç½®ï¼ˆä¸¤ç«¯ç©ºï¼‰
            total_width = sum(i['item_width'] for i in new_items)
            num_items = len(new_items)
            spacing = math.floor((total_layer_width - total_width) / (num_items + 1)) if num_items > 0 else 0
            pos = spacing
            for item in new_items:
                item['position'] = pos
                pos += item['item_width'] + spacing

            updated_layers.append(pd.DataFrame(new_items))

        # åˆå¹¶æ›´æ–°å±‚ä¸æœªå—å½±å“å±‚
        if not updated_layers:
            return pog_data, {'status': 'success', 'msg': 'æ— å¯æ›´æ–°å±‚'}

        new_layers = pd.concat(updated_layers, ignore_index=True)
        unaffected = pog_data.set_index(['module_id', 'layer_id']).drop(
            index=pd.MultiIndex.from_tuples(self.affected_layers_by_removal, names=['module_id', 'layer_id']),
            errors='ignore'
        ).reset_index()
        new_pog = pd.concat([unaffected, new_layers], ignore_index=True)

        print("âœ… DP-based å¡«å……ä¸é‡æ–°å®šä½å®Œæˆã€‚")
        return new_pog, {'status': 'success', 'msg': 'å¡«å……ä¸é‡æ–°å®šä½æˆåŠŸ'}

    def run_delete_fill_pipeline(self, var_dict: Dict) -> Tuple[pd.DataFrame, Dict]:
        # ç»Ÿä¸€ item_code ä¸º str
        pog_data = var_dict['bases_data']['pog_data']
        pog_data = pog_data.copy()
        pog_data['item_code'] = pog_data['item_code'].astype(str)
        var_dict['bases_data']['pog_data'] = pog_data

        # load sales and compute revenue = sales * qty (if provided)
        sales_df = var_dict['bases_data'].get('sales_item_sum', None)
        if sales_df is not None and not sales_df.empty:
            sales_df = sales_df.copy()
            # ensure columns
            if 'item_code' in sales_df.columns and 'sales' in sales_df.columns and 'qty' in sales_df.columns:
                sales_df['item_code'] = sales_df['item_code'].astype(str)
                sales_df['revenue'] = sales_df['sales'].astype(float) * sales_df['qty'].astype(float)
                self.sales_df = sales_df[['item_code', 'revenue']].copy()
                print("âœ… å·²è½½å…¥ sales_item_sumï¼Œå¹¶è®¡ç®— revenue = sales * qtyã€‚")
            else:
                print("âš ï¸ sales_item_sum æ–‡ä»¶ç¼ºå°‘å¿…è¦åˆ— (item_code, sales, qty)ã€‚å°†é»˜è®¤ revenue=0ã€‚")
                self.sales_df = None
        else:
            print("â„¹ï¸ æœªæä¾› sales_item_sumï¼Œdouble é€‰æ‹©é»˜è®¤ revenue=0ã€‚")
            self.sales_df = None

        # step1: åˆ é™¤ï¼ˆé™å®šå±‚ï¼‰
        new_pog, status = self.remove_sku_items(var_dict)
        if status.get('status') == 'fail':
            return new_pog, status

        # step2: è®¡ç®—å—å½±å“å±‚ç©ºé—´å¹¶æ’åº
        self.calculate_space_for_affected_layers(new_pog)
        self.sort_items_by_position(new_pog)

        # step3: ä½¿ç”¨ DP è¿›è¡Œå¡«å……ä¸é‡æ’
        final_pog, status2 = self.fill_and_reposition_layers(new_pog)
        return final_pog, status2


# ===========================
# âœ… ç¤ºä¾‹è°ƒç”¨
# ===========================
if __name__ == "__main__":
    pog_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_result.csv"
    tray_item_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_test_haircare_tray_item.csv"
    sales_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\sales_item_sum.csv"

    var_dict = {
        'bases_data': {
            'pog_data': pd.read_csv(pog_file),
            'tray_item': pd.read_csv(tray_item_file),
            'sales_item_sum': pd.read_csv(sales_file)
        },
        'func': {
            'del_item_func': {
                'del_item_list': ['101425031'],
                'target_module_id': 6,
                'target_layer_id': 2
            }
        }
    }

    filler = FillLayerSKU()
    new_pog, status = filler.run_delete_fill_pipeline(var_dict)

    print(status)
    if status['status'] == 'success':
        output_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_result_final_output.csv"
        new_pog.to_csv(output_file, index=False, encoding='utf-8-sig')
        print(f"âœ… æœ€ç»ˆç»“æœå·²å¯¼å‡ºè‡³: {output_file}")
    else:
        print("âŒ æ“ä½œå¤±è´¥ï¼š", status.get('msg', 'æœªçŸ¥é”™è¯¯'))
