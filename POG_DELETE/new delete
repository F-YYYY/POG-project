import pandas as pd
from typing import Dict, Optional, List, Tuple


class RemoveSKU:
    """
    RemoveSKU ç±»
    ------------------
    ä»POGä¸­åˆ é™¤æŒ‡å®šSKUï¼Œå¹¶ç¦æ­¢åˆ é™¤æ‰˜ç›˜(tray)æˆ–æ‰˜ç›˜ä¸Šçš„å•†å“ã€‚
    æ–°å¢åŠŸèƒ½ï¼š
    âœ… æ”¯æŒæŒ‰æŒ‡å®š module_idã€layer_id ç²¾ç¡®åŒ¹é…æ‰˜ç›˜ã€‚
    """

    def __init__(self):
        self.dataframes: Dict[str, pd.DataFrame] = {}
        self.affected_layers_by_removal: List[Tuple[int, int]] = []
        print("âœ… RemoveSKU åˆå§‹åŒ–å®Œæˆã€‚")

    def remove_sku_items(self, var_dict: Dict):
        pog_data = var_dict['bases_data']['pog_data']
        tray_item_data = var_dict['bases_data'].get('tray_item', None)
        params = var_dict['func'].get('del_item_func', {})

        delete_skus = params.get('del_item_list', [])
        fixed_module_id = params.get('module_id', None)
        fixed_layer_id = params.get('layer_id', None)

        print(f"\n--- å¼€å§‹æ‰§è¡Œ 'remove_sku_items' åˆ é™¤SKU: {delete_skus} ---")
        print(f"ğŸ“ å›ºå®šèŒƒå›´ï¼šmodule_id={fixed_module_id}, layer_id={fixed_layer_id}")

        if pog_data is None or pog_data.empty:
            return pog_data, {'status': 'fail', 'msg': 'POGæ•°æ®ä¸ºç©º'}

        pog_data['item_code'] = pog_data['item_code'].astype(str)

        # ==== tray-item å¯¹åº”å…³ç³» ====
        tray_items = []
        tray_links = {}
        if tray_item_data is not None and not tray_item_data.empty:
            try:
                tray_pair_df = tray_item_data.iloc[:, [0, 1]].copy()
                tray_pair_df.columns = ['tray_id', 'item_code']
                tray_pair_df['tray_id'] = tray_pair_df['tray_id'].astype(str)
                tray_pair_df['item_code'] = tray_pair_df['item_code'].astype(str)
                tray_items = tray_pair_df['item_code'].tolist()
                tray_links = dict(zip(tray_pair_df['item_code'], tray_pair_df['tray_id']))
                print(f"ğŸ“¦ æ‰˜ç›˜å•†å“è¯†åˆ«æˆåŠŸï¼šå…± {len(tray_items)} ä¸ª tray-item å…³è”ã€‚")
            except Exception as e:
                print(f"âš ï¸ è¯»å– tray_item æ–‡ä»¶å‡ºé”™: {e}")

        # ==== æ£€æŸ¥ç›®æ ‡å±‚ ====
        if fixed_module_id is not None and fixed_layer_id is not None:
            target_layer = pog_data[
                (pog_data['module_id'] == fixed_module_id) &
                (pog_data['layer_id'] == fixed_layer_id)
            ]
        else:
            target_layer = pog_data

        # ==== ç¦æ­¢åˆ é™¤æ‰˜ç›˜è‡ªèº« ====
        if 'item_type' in pog_data.columns:
            tray_self = target_layer.loc[target_layer['item_type'] == 'tray', 'item_code'].astype(str).tolist()
            for code in delete_skus:
                if str(code) in tray_self:
                    return pog_data, {
                        'status': 'fail',
                        'msg': f'åˆ é™¤å¤±è´¥ï¼šSKU {code} æ˜¯æ‰˜ç›˜(tray)å•†å“ï¼Œç¦æ­¢åˆ é™¤ã€‚'
                    }

        # ==== ç¦æ­¢åˆ é™¤æ‰˜ç›˜ä¸Šçš„å•†å“ ====
        for code in delete_skus:
            if str(code) in tray_items:
                tray_id = tray_links.get(str(code))
                # æ£€æŸ¥è¯¥ tray æ˜¯å¦å‡ºç°åœ¨å½“å‰å±‚
                tray_exist = target_layer[target_layer['item_code'] == tray_id]
                if not tray_exist.empty:
                    return pog_data, {
                        'status': 'fail',
                        'msg': f'åˆ é™¤å¤±è´¥ï¼šSKU {code} ä½äºæœ¬å±‚æ‰˜ç›˜ {tray_id} ä¸Šï¼Œç¦æ­¢åˆ é™¤ã€‚'
                    }

        # ==== ç¡®è®¤æ˜¯å¦æ‰¾åˆ°è¯¥å•†å“ ====
        found_rows = target_layer[target_layer['item_code'].isin(delete_skus)]
        if found_rows.empty:
            return pog_data, {
                'status': 'fail',
                'msg': f'æœªæ‰¾åˆ°å•†å“ {delete_skus} äºæŒ‡å®šæ¨¡å— {fixed_module_id}-{fixed_layer_id}'
            }

        # ==== è®°å½•å—å½±å“å±‚ ====
        affected_layers = found_rows[['module_id', 'layer_id']].drop_duplicates()
        self.affected_layers_by_removal = [tuple(x) for x in affected_layers.to_numpy()]

        # ==== æ‰§è¡Œåˆ é™¤ ====
        new_pog = pog_data.drop(found_rows.index)
        removed_num = len(found_rows)
        print(f"ğŸ—‘ï¸ å·²åˆ é™¤ {removed_num} æ¡SKUè®°å½•ã€‚")

        return new_pog, {'status': 'success', 'msg': f'æˆåŠŸåˆ é™¤ {removed_num} ä¸ªSKU'}


class FillLayerSKU(RemoveSKU):
    """
    FillLayerSKU ç±»
    ------------------
    åˆ é™¤SKUåï¼š
    âœ… æ£€æµ‹tray
    âœ… è®¡ç®—å‰©ä½™ç©ºé—´
    âœ… ç»“åˆsalesæ•°æ®é€‰æ‹©é”€å”®é¢æœ€é«˜çš„å•†å“ double-facing
    âœ… å¦åˆ™ç­‰è·é‡æ’
    """

    def __init__(self):
        super().__init__()
        self.affected_layer_space: Optional[pd.DataFrame] = None
        self.sorted_items_by_position: Dict[Tuple[int, int], pd.DataFrame] = {}
        self.sales_df: Optional[pd.DataFrame] = None
        print("âœ… FillLayerSKU åˆå§‹åŒ–å®Œæˆã€‚")

    def analyze_layer_space(self, pog_data: pd.DataFrame, total_layer_width: int = 1000) -> pd.DataFrame:
        if pog_data.empty:
            return pd.DataFrame(columns=['module_id', 'layer_id', 'item_count', 'used_width', 'remaining_width'])
        layer_summary = pog_data.groupby(['module_id', 'layer_id']).agg(
            used_width=('item_width', 'sum'),
            item_count=('item_code', 'count')
        ).reset_index()
        layer_summary['total_width'] = total_layer_width
        layer_summary['remaining_width'] = layer_summary['total_width'] - layer_summary['used_width']
        return layer_summary

    def calculate_space_for_affected_layers(self, pog_data: pd.DataFrame, total_layer_width: int = 1000):
        print("\n--- è®¡ç®—å—å½±å“å±‚å‰©ä½™ç©ºé—´ ---")
        if not self.affected_layers_by_removal:
            print("â„¹ï¸ æ— å—å½±å“å±‚ã€‚")
            return
        all_layers = self.analyze_layer_space(pog_data, total_layer_width)
        affected = all_layers.set_index(['module_id', 'layer_id']).reindex(self.affected_layers_by_removal)
        self.affected_layer_space = affected.reset_index()
        print("âœ… å—å½±å“å±‚ç©ºé—´è®¡ç®—å®Œæˆã€‚")

    def sort_items_by_position(self, pog_data: pd.DataFrame):
        print("\n--- æ’åºå—å½±å“å±‚å†…å•†å“ ---")
        for mod_id, lay_id in self.affected_layers_by_removal:
            df = pog_data[(pog_data['module_id'] == mod_id) & (pog_data['layer_id'] == lay_id)].copy()
            if df.empty:
                continue
            sorted_df = df.sort_values(by='position')
            self.sorted_items_by_position[(mod_id, lay_id)] = sorted_df
        print("âœ… æ’åºå®Œæˆã€‚")

    def fill_and_reposition_layers(self, pog_data: pd.DataFrame, total_layer_width: int = 1000):
        print("\n--- å¼€å§‹æ‰§è¡Œå¡«å……ä¸é‡æ–°å®šä½ ---")
        updated_layers = []
        for layer_key, layer_df in self.sorted_items_by_position.items():
            mod_id, lay_id = layer_key
            layer_space = self.analyze_layer_space(pog_data)
            remain = layer_space[
                (layer_space['module_id'] == mod_id) &
                (layer_space['layer_id'] == lay_id)
            ]['remaining_width'].iloc[0]
            current_remain = remain

            # ==== æ ¹æ® sales æ’åº ====
            layer_df = layer_df.copy()
            if self.sales_df is not None:
                self.sales_df['item_code'] = self.sales_df['item_code'].astype(str)
                layer_df = layer_df.merge(self.sales_df[['item_code', 'sales']], on='item_code', how='left')
            else:
                layer_df['sales'] = 0

            layer_df = layer_df.sort_values(by='sales', ascending=False)

            copies_to_add = {}
            for _, row in layer_df.iterrows():
                width = row['item_width']
                code = row['item_code']
                if current_remain >= width:
                    copies_to_add[code] = 1
                    current_remain -= width
                    print(f"ğŸ’° åŒé™ˆåˆ—å•†å“é€‰æ‹©ï¼š{code} (sales={row['sales']})")
                    break
            else:
                print(f"â„¹ï¸ æœ¬å±‚ {mod_id}-{lay_id} æ— å¯åŒé™ˆåˆ—å•†å“ã€‚")

            # ==== é‡æ–°å¸ƒå±€ ====
            new_items = []
            for _, row in layer_df.iterrows():
                new_items.append(row.to_dict())
                if row['item_code'] in copies_to_add:
                    copy = row.to_dict()
                    copy['position'] = -1
                    new_items.append(copy)

            total_width = sum(i['item_width'] for i in new_items)
            spacing = (total_layer_width - total_width) / (len(new_items) + 1)
            pos = spacing
            for item in new_items:
                item['position'] = pos
                pos += item['item_width'] + spacing

            updated_layers.append(pd.DataFrame(new_items))

        if not updated_layers:
            return pog_data, {'status': 'success', 'msg': 'æ— å¯æ›´æ–°å±‚'}

        new_layers = pd.concat(updated_layers, ignore_index=True)
        unaffected = pog_data.set_index(['module_id', 'layer_id']).drop(
            index=pd.MultiIndex.from_tuples(self.affected_layers_by_removal, names=['module_id', 'layer_id']),
            errors='ignore'
        ).reset_index()
        new_pog = pd.concat([unaffected, new_layers], ignore_index=True)
        print("âœ… å¡«å……ä¸é‡æ–°å®šä½å®Œæˆã€‚")
        return new_pog, {'status': 'success', 'msg': 'å¡«å……ä¸é‡æ–°å®šä½æˆåŠŸ'}

    def run_delete_fill_pipeline(self, var_dict: Dict) -> Tuple[pd.DataFrame, Dict]:
        pog_data = var_dict['bases_data']['pog_data']
        pog_data['item_code'] = pog_data['item_code'].astype(str)
        self.sales_df = var_dict['bases_data'].get('sales_item_sum', None)

        var_dict['bases_data']['pog_data'] = pog_data

        new_pog, status = self.remove_sku_items(var_dict)
        if status['status'] == 'fail':
            return new_pog, status

        self.calculate_space_for_affected_layers(new_pog)
        self.sort_items_by_position(new_pog)
        final_pog, status2 = self.fill_and_reposition_layers(new_pog)
        return final_pog, status2


# ===========================
# âœ… ç¤ºä¾‹è°ƒç”¨
# ===========================
if __name__ == "__main__":
    pog_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_result.csv"
    tray_item_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_test_haircare_tray_item.csv"
    sales_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\sales_item_sum.csv"

    var_dict = {
        'bases_data': {
            'pog_data': pd.read_csv(pog_file),
            'tray_item': pd.read_csv(tray_item_file),
            'sales_item_sum': pd.read_csv(sales_file)
        },
        'func': {
            'del_item_func': {
                'del_item_list': ['101473131'],
                'module_id': 6,
                'layer_id': 2
            }
        }
    }

    filler = FillLayerSKU()
    new_pog, status = filler.run_delete_fill_pipeline(var_dict)

    print(status)
    if status['status'] == 'success':
        output_file = r"C:\Users\fy\Desktop\POG\æ–°çš„\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\å¼€å‘æ‰€éœ€æµ‹è¯•æ•°æ®\pog_result_final_output.csv"
        new_pog.to_csv(output_file, index=False, encoding='utf-8-sig')
        print(f"âœ… æœ€ç»ˆç»“æœå·²å¯¼å‡ºè‡³: {output_file}")
    else:
        print("âŒ æ“ä½œå¤±è´¥ï¼š", status.get('msg', 'æœªçŸ¥é”™è¯¯'))
